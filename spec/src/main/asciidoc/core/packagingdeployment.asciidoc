[[packaging_deployment]]

== Packaging and deployment

Before an application is started, or during application startup, the container must perform _bean discovery_, execute build compatible extensions, and detect definition errors and deployment problems.

Bean discovery is the process of determining:

* Bean archives within application, and any beans contained within them
* Which alternatives and interceptors are _enabled_
* The _ordering_ of enabled interceptors

Additional beans may be registered programmatically via <<spi_lite>>.

[[bean_archive]]

=== Bean archives

Bean classes of enabled beans must be deployed in _bean archives_.

A bean archive has a _bean discovery mode_ of either `annotated` or `none`.
This is governed by presence of `beans.xml` file which can be either empty or it can declare the `bean-discovery-mode` attribute.
Default value for this attribute is `annotated`.

An archive which:

* contains a `beans.xml` file with the `bean-discovery-mode` of `none`, or,
* contains a portable extension or a build compatible extension and no `beans.xml` file

is not a bean archive.

An _implicit bean archive_ is:

* an archive which contains a `beans.xml` file that is empty, or,
* an archive which contains a `beans.xml` file that has `bean-discovery-mode` attribute set to `annotated`

When determining which archives are bean archives, the container must consider all JAR archives available through implementation-specific means.
Implementations are required to document how the candidate JAR archives are found.

The `beans.xml` file must be named:

* `META-INF/beans.xml`.

The container searches for beans in all bean archives discovered as described above.

If a bean class is deployed in two different bean archives, non-portable behavior results.
Portable applications must deploy each bean class in no more than one bean archive.

Implicit bean archives are likely to contain classes which are not deployed as beans.

An extension may be deployed in any archive, including those that are not bean archives.

[[initialization]]

=== Application initialization lifecycle

// TODO related to https://github.com/eclipse-ee4j/cdi/issues/482
// also related to https://github.com/eclipse-ee4j/cdi/issues/496
// Capture init process WRT build compatible extensions + type discovery + bean discovery
// see <<initialization>> for format that is used for CDI Full

[[shutdown]]

=== Application shutdown lifecycle

When an application is stopped, the container must destroy all contexts.

[[type_bean_discovery]]

=== Type and Bean discovery

The container automatically discovers managed beans (according to the rules of <<what_classes_are_beans>>) in bean archives and searches the bean classes for producer methods, producer fields, disposer methods and observer methods.

[[type_discovery_steps]]

==== Type discovery

First the container must discover types.
The container discovers each Java class with a bean defining annotation in an implicit bean archive.

// TODO at this point, we should probably mention build compatible extensions and how you can get notified of events and change these types
// we should mention Enhancement phase here and link to the relevant doc part
// related to https://github.com/eclipse-ee4j/cdi/issues/483

[[bean_discovery_steps]]

==== Bean discovery

For every type in the set of discovered types (as defined in <<type_discovery_steps>>), the container must:

* inspect the type metadata to determine if it is a bean, and then
* detect definition errors by validating the class and its metadata, and then
* determine which alternatives and interceptors are enabled, according to the rules defined in <<enablement>>.
// TODO mention any events we fire for build compatible extensions at this point - Processing
// e.g. if we have an equivalent of ProcessBeanAttributes and/or ProcessBean
// related to https://github.com/eclipse-ee4j/cdi/issues/483

For each enabled bean, the container must search the class for producer methods and fields, as defined in <<producer_method>> and in <<producer_field>>, including resources, and for each producer:

// TODO mention any events we fire for build compatible extensions at this point - Processing
// e.g. if we have an equivalent of ProcessInjectionPoint and/or ProcessProducer and/or ProcessBeanAttributes and/or ProcessBean
// related to https://github.com/eclipse-ee4j/cdi/issues/483

For each enabled bean, the container must search the class for observer methods, and for each observer method:

// TODO mention build compatible extension equivalent - Processing
// e.g. if we have an equivalent of ProcessObserverMethod
// related to https://github.com/eclipse-ee4j/cdi/issues/483

Then, the container registers the `Bean` and `ObserverMethod` objects:

* For each enabled bean that is not an interceptor, the container registers an instance of the `Bean` interface defined in <<bean>>.
* For each enabled interceptor, the container registers an instance of the `Interceptor` interface defined in <<interceptor>>.
* For each observer method of every enabled bean, the container registers an instance of the `ObserverMethod` interface defined in <<observer_method>>.
