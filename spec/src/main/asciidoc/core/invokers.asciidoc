////
Copyright (c) 2023 Red Hat, Inc. and others

This program and the accompanying materials are made available under the
Apache Software License 2.0 which is available at:
https://www.apache.org/licenses/LICENSE-2.0.

SPDX-License-Identifier: Apache-2.0
////
[[method_invokers]]
== Method invokers

CDI-based frameworks often need to invoke application methods declared on managed beans.
Frameworks cannot invoke application methods directly, because they are not compiled against the application code.
However, during application deployment, frameworks may observe application methods through CDI extensions and build an `Invoker` for each relevant method.
The invokers can then be used at application runtime to invoke the methods indirectly.

Method invokers are not supposed to be used by application code, as applications may invoke their own methods directly.

[[building_invoker]]
=== Building an `Invoker`

The CDI container allows building an `Invoker` for a method of an <<enablement,enabled>> <<managed_beans,managed bean>>.
The method for which the invoker is built is called the _target method_ of the invoker, and the managed bean is called the _target bean_ of the invoker.

Invalid target methods are:

* private methods,
* constructors,
* methods declared on the `java.lang.Object` class, except for the `toString()` method,
* methods that are not declared on the bean class of the target bean or inherited from its supertypes.

Attempting to build an invoker for an invalid target method leads to a deployment problem.

Attempting to build an invoker for a non-static target method declared on a type that is not present in the set of bean types of the target bean leads to non-portable behavior.
When the target bean is normal scoped, attempting to build an invoker for a non-static target method declared on an <<unproxyable,unproxyable>> bean type of the target bean leads to non-portable behavior.

When the target bean is not a managed bean, attempting to build an invoker leads to a deployment problem.
When the target bean is an interceptor, attempting to build an invoker leads to a deployment problem.

Multiple managed beans may inherit a method from a common supertype.
In that case, an invoker must be built for each target bean individually.
An invoker built for one target bean may not be used to invoke the target method on an instance of another target bean.

The only way to build an invoker is using the `InvokerBuilder`.
An `InvokerBuilder` can only be obtained in CDI portable extensions and build compatible extensions.
See <<invoker_builder>> for more information.

[[using_invoker]]
=== Using an `Invoker`

The `Invoker` interface contains a single method:

[source,java]
----
public interface Invoker<T, R> {
    R invoke(T instance, Object[] arguments) throws Exception;
}
----

Calling `invoke()` invokes the target method on given `instance` of the target bean, passing given `arguments`, and propagates back the return value or thrown exception.
The `instance` and `arguments` may be contextual or non-contextual objects.

A single invoker instance may be used to perform multiple invocations of the target method, possibly on different instances of the target bean, possibly with different arguments.
Invoker implementations must be thread-safe.
Whether concurrent invocations of the target method are safe depends on the implementation of the target bean and is not generally guaranteed.

Whenever a direct invocation of a method on an object is a business method invocation, an indirect invocation of that method on that object through an invoker is also a business method invocation.

[[invoke_behavior]]
==== Behavior of `invoke()`

If the target method is `static`, the `instance` is ignored; by convention, it should be `null`.
If the target method is not `static` and `instance` is `null`, a `RuntimeException` is thrown.
If the target method is not `static` and the `instance` is not permissible for the target method, a `RuntimeException` is thrown.

The `instance` is permissible for the target method when:

* the `instance` is a contextual reference for the target bean and the bean type that declares the target method, or
* the `instance` is a contextual reference for the target bean (regardless of the bean type) and the target method is declared on an interface that is present in the set of bean types of the target bean (see <<typecasting_between_bean_types>>), or
* the `instance` is a non-contextual object and the class of the `instance` declares the target method or inherits it from a supertype, or
* in other, non-portable (implementation defined) cases.

Correspondence between given `arguments` and declared parameters of the target method is positional: the Nth element of the `arguments` array is passed as the Nth argument to the target method.
If the target method is a variable arity method, the last element of the `arguments` array corresponds to the variable arity parameter (and therefore must be an array).
When passing an argument to the method, the applicable method invocation conversion is performed.

If the target method declares no parameter, `arguments` are ignored.
If the target method declares any parameter and `arguments` is `null`, `RuntimeException` is thrown.
If the `arguments` array has fewer elements than the number of parameters of the target method, `RuntimeException` is thrown.
If the `arguments` array has more elements than the number of parameters of the target method, the excess elements are ignored.
If a method invocation conversion does not exist from the class of some of the `arguments` (or from the null type if the argument is `null`) to the declared type of the corresponding parameter of the target method, `RuntimeException` is thrown.

NOTE: The type checking and conversion rules are aligned with pre-existing mechanisms for indirect method invocations, the Java reflection API and the method handles API.

When the declared type of a parameter of the target method is not a reifiable type, callers of `Invoker.invoke()` must ensure that the corresponding argument is constructed appropriately.
Otherwise, runtime failures are likely to occur.

If the target method returns normally, its return value is returned (after boxing conversion if the target method's return type is a primitive type), unless the target method is declared `void`, in which case `null` is returned.
If the target method throws an exception, it is rethrown directly.

==== Example

To illustrate how method invokers work, let's take a look at an example.
Say that the following bean exists in an application and has a method that you, the framework author, want to invoke indirectly:

[source,java]
----
@Dependent
public class MyService {
    public String hello(String name) {
        return "Hello " + name + "!";
    }
}
----

In a CDI extension, you obtain an `InvokerBuilder` for the `hello()` method and use it to build an invoker.
In a portable extension (see <<invoker_builder_full>>), this results in an invoker which should be stored for later usage:

[source,java]
----
InvokerBuilder<Invoker<MyService, String>> builder = ...;
Invoker<MyService, String> invoker = builder.build();
----

In a build compatible extension (see <<invoker_builder>>), this results in an opaque token that materializes as an `Invoker` at application runtime:

[source,java]
----
InvokerBuilder<InvokerInfo> builder = ...;
InvokerInfo invoker = builder.build();
----

To call the `hello()` method through this invoker, assuming that `myService` is a contextual reference for the bean, call:

[source,java]
----
invoker.invoke(myService, new Object[] {"world"})
----

The return value is `"Hello world!"`.

Internally, the container will create an implementation of the invoker, equivalent to the following class:

[source,java]
----
public class TheInvoker implements Invoker<MyService, String> {
    public String invoke(MyService instance, Object[] arguments) {
        return instance.hello((String) arguments[0]);
    }
}
----

[[invoker_builder]]
=== Using `InvokerBuilder`

`InvokerBuilder` can be obtained in build compatible extensions from `InvokerFactory.createInvoker()`:

[source,java]
----
public interface InvokerFactory {
    InvokerBuilder<InvokerInfo> createInvoker(BeanInfo bean, MethodInfo method);
}
----

An `InvokerFactory` may be declared as a parameter of `@Registration` extension methods.

The target bean of the created invoker is the bean represented by the `BeanInfo` object passed to `createInvoker()`.
The target method of the created invoker is the method represented by the `MethodInfo` object passed to `createInvoker()`.

[source,java]
----
public interface InvokerBuilder<T> {
    ...

    T build();
}
----

Calling `InvokerBuilder.build()` produces an opaque token (`InvokerInfo`) that can be passed as a parameter to a `SyntheticBeanBuilder` or `SyntheticObserverBuilder` and materializes as an `Invoker` at application runtime.

[[invoker_lookups]]
==== Configuring invoker lookups

The `InvokerBuilder` allows configuring that the `instance` or any of the `arguments` passed to `Invoker.invoke()` should be ignored and a value should be looked up from the CDI container instead.

[source,java]
----
public interface InvokerBuilder<T> {
    InvokerBuilder<T> withInstanceLookup();
    InvokerBuilder<T> withArgumentLookup(int position);
}
----

When `withInstanceLookup()` is called on an invoker builder and the target method is not `static`, the `invoke()` method of the built invoker shall ignore the `instance` argument and instead obtain and use a contextual reference for the target bean and the bean type that declares the target method.
Calling `withInstanceLookup()` on an invoker builder for a `static` target method has no effect.

When `withArgumentLookup()` is called on an invoker builder, the `invoke()` method of the built invoker shall ignore the given element of the `arguments` array and instead:

1. identify a bean according to the rules of typesafe resolution, as defined in <<performing_typesafe_resolution>>, where the required type is the declared type of the corresponding parameter of the target method and the required qualifiers are all qualifiers present on the parameter, resolving ambiguities according to <<unsatisfied_and_ambig_dependencies>>;
2. obtain and use a contextual reference for the identified bean and the declared type of the parameter.

Calling `withArgumentLookup()` with `position` less than 0 or greater than or equal to the number of parameters of the target method leads to an `IllegalArgumentException`.

Configuring a lookup using `withInstanceLookup()` or `withArgumentLookup()` does not relax the requirements defined in <<invoke_behavior>>.
Notably, the `arguments` array must still have an element for each argument, regardless of whether a lookup was configured for it.
This means that for a target method with N parameters, the `arguments` array must always have at least N elements.

In the following paragraphs, the beans whose instances shall be obtained by `Invoker.invoke()` as a result of calling `withInstanceLookup()` and `withArgumentLookup()` are called _looked up beans_.

During deployment validation, implementations are required to identify all looked up beans for all built invokers, as described above.
It is a deployment problem if an attempt to identify a looked up bean results in an unsatisfied dependency or an ambiguous dependency that is not resolvable.
Implementations are permitted to remember the identified beans and not repeat the resolution process for each invocation of `Invoker.invoke()`.

All instances of `@Dependent` looked up beans obtained during `Invoker.invoke()` are destroyed before the `invoke()` method returns or throws.
(See <<invoker_asynchronous_methods>> for a variation of this rule for asynchronous methods.)
The order in which the instances of `@Dependent` looked up beans are destroyed is not specified.

The order in which instances of looked up beans are obtained during `Invoker.invoke()` in not specified.

If an exception is thrown when creating an instance of a looked up bean during `Invoker.invoke()`, the exception is rethrown.

NOTE: Destroying an instance is not permitted to throw an exception.
See <<contextual>> for more information.

[[invoker_asynchronous_methods]]
===== Asynchronous methods

Sometimes, the action started by the method does not necessarily finish when the method returns; the _completion_ of the action is asynchronous to the method call.
Such methods are called _asynchronous_ methods.
Method invokers have special support for asynchronous methods when it comes to destroying instances of looked up `@Dependent` beans.

[source,java]
----
public interface AsyncHandler<T> {
    T transform(T original, Runnable completion);
}
----

An _async handler_ is a service provider of `jakarta.enterprise.invoke.AsyncHandler`.
An async handler may not declare a provider method; it must declare a provider constructor.
An async handler must have a direct superinterface type that is a parameterized type whose generic interface is `AsyncHandler` and its sole type argument is a class type, interface type or parameterized type, otherwise deployment problem occurs.
The erasure of the type argument to `AsyncHandler` is called the _async type_ of the async handler.
An async handler must be stateless (and therefore thread safe); there are no guarantees about its lifecycle.

Each async handler must be annotated either `@AsyncHandler.ReturnType` or `@AsyncHandler.ParameterType`, otherwise deployment problem occurs.
If an async handler is annotated `@AsyncHandler.ReturnType`, the target method matches the async handler if the erasure of its return type is identical to the async type of the async handler.
If an async handler is annotated `@AsyncHandler.ParameterType`, the target method matches the async handler if it declares exactly one parameter whose type's erasure is identical to the async type of the async handler; this parameter is called an _async parameter_.

If the target method matches exactly one async handler, the invoker becomes asynchronous.
An asynchronous invoker calls the `transform()` method of the matching async handler exactly once during `invoke()`.
If the matching async handler is annotated `@AsyncHandler.ReturnType`, the `transform()` method is called after the target method is called, with the return value of the target method as the `original`, and the result is returned to the caller.
If the matching async handler is annotated `@AsyncHandler.ParameterType`, the `transform()` method is called before the target method is called, with the given argument value of the async parameter as the `original`, and the result is passed to the target method as the argument value of the async parameter.
The async handler signals completion of the asynchronous action by calling `completion.run()`.

The requirement to destroy instances of `@Dependent` looked up beans is different for asynchronous invokers.
The instances of `@Dependent` looked up beans are destroyed when the asynchronous action completes, as signalled by the async handler.
If an asynchronous target method throws synchronously, instances of `@Dependent` looked up beans are destroyed before `invoke()` rethrows the exception; in this case, the async handler is still permitted to call `completion.run()`, but the call must be ignored.

The CDI container must include async handlers for the following return types:

- `java.util.concurrent.CompletionStage`
- `java.util.concurrent.CompletableFuture`
- `java.util.concurrent.Flow.Publisher`

If the target method matches more than one async handler, by default a deployment problem occurs.
Containers are required to provide implementation-defined means of configuring an async handler that should be used for any given async type.
If such configuration is present, other async handlers for the given async type are ignored; the target method only matches the configured async handler.
If the configured async handler does not exist, deployment problem occurs.
It is possible to configure a custom async handler for the built-in return types listed above.

Containers are encouraged to detect asynchronous methods for which an invoker is built but a matching async handler does not exist and provide a warning in a suitable form.
Such detection is likely based on a set of well-known asynchronous types.
