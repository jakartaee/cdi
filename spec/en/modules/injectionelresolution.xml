<?xml version="1.0" encoding="UTF-8"?>
<chapter id="injectionelresolution">
  <title>Dependency injection, lookup and EL</title>
  
  <para>The container injects references to contextual instances to the 
  following kinds of <emphasis>injection point</emphasis>:</para>
  
  <itemizedlist>
    <listitem>
      <para>Any injected field of a bean class</para>
    </listitem>
    <listitem>
      <para>Any parameter of a bean constructor, initializer method, 
      producer method or disposer method</para> 
    </listitem>
    <listitem>
      <para>Any parameter of an observer method, except for the event 
      parameter</para> 
    </listitem>
  </itemizedlist>
  
  <para>References to contextual instances may also be obtained by 
  programmatic lookup or by Unified EL expression evaluation.</para>

  <para>In general, a bean type or bean EL name does not uniquely identify a
  bean. When resolving a bean at an injection point, the container considers 
  bean type, qualifiers and alternative declarations in <literal>beans.xml</literal>. 
  When resolving a name in an EL expression, the container considers the bean 
  name and alternative declarations in <literal>beans.xml</literal>. This allows 
  bean developers to decouple type from implementation.</para>
  
  <para>The container is required to support circularities in the bean dependency 
  graph where at least one bean participating in every circular chain of 
  dependencies has a normal scope, as defined in <xref linkend="normalscope"/>. 
  The container is not required to support circular chains of dependencies where 
  every bean participating in the chain has a pseudo-scope.</para>
  
  <section id="selection">
    <title>Modularity</title>
    
    <para>Beans and their clients may be deployed in <emphasis>modules</emphasis> in 
    a module architecture such as the Java EE environment. In a module architecture, 
    certain modules are considered <emphasis>bean archives</emphasis>. In the Java EE 
    module architecture, any Java EE module or library is a module. The Java EE module 
    or library is a bean archive if it contains a <literal>beans.xml</literal> file, 
    as defined in <xref linkend="beanarchive"/>.</para>
    
    <para>A bean packaged in a certain module is available for injection, lookup 
    and EL resolution to classes and JSP/JSF pages packaged in some other module 
    if and only if the bean class of the bean is required to be 
    <emphasis>accessible</emphasis> to the other module by the class accessibility 
    requirements of the module architecture. In the Java EE module architecture, 
    a bean class is accessible in a module if and only if it is required to be
    accessible according to the class loading requirements defined by the Java EE 
    platform specification.</para>
    
    <para>Note that, in some Java EE implementations, a bean class might be accessible to 
    some other class even when this is not required by the Java EE platform specification. 
    For the purposes of this specification, a class is not considered accessible to 
    another class unless accessibility is explicitly required by the Java EE platform 
    specification.</para>
    
    <para>An alternative is not available for injection, lookup or EL resolution to 
    classes or JSP/JSF pages in a module unless the module is a bean archive and the 
    alternative is explicitly <emphasis>selected</emphasis> in that bean archive. An 
    alternative is never available for injection, lookup or EL resolution in a module 
    that is not a bean archive.</para>
    
    <section>
      <title>Declaring selected alternatives for a bean archive</title>
    
    <para>By default, a bean archive has no selected alternatives. An alternative must be 
    explicitly declared using the <literal>&lt;alternatives&gt;</literal> element of the 
    <literal>beans.xml</literal> file of the bean archive. The 
    <literal>&lt;alternatives&gt;</literal> element contains a list of bean classes and 
    stereotypes. An alternative is selected for the bean archive if either:</para>
    
    <itemizedlist>
      <listitem>
        <para>the alternative is a managed bean or session bean and the bean class of the
        bean is listed,</para>
      </listitem>
      <listitem>
        <para>the alternative is a producer method, field or resource, and the bean class 
        that declares the method or field is listed, or</para>
      </listitem>
      <listitem>
        <para>any <literal>@Alternative</literal> stereotype of the alternative is listed.</para>
      </listitem>
    </itemizedlist>
    
    <programlisting><![CDATA[<beans xmlns="http://java.sun.com/xml/ns/javaee"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/beans_1_0.xsd">
   <alternatives>
      <class>org.mycompany.myfwk.InMemoryDatabase</class>
      <stereotype>org.mycompany.myfwk.Mock</stereotype>
      <stereotype>org.mycompany.site.Australian</stereotype>
   </alternatives>
</beans>]]></programlisting>

    <para>Each child <literal>&lt;class&gt;</literal> element must specify the name of an 
    alternative bean class. If there is no class with the specified name, or if the class with 
    the specified name is not an alternative bean class, the container automatically detects the 
    problem and treats it as a deployment problem.</para>
    
    <para>Each child <literal>&lt;stereotype&gt;</literal> element must specify the name 
    of an <literal>@Alternative</literal> stereotype annotation. If there is no annotation with 
    the specified name, or the annotation is not an <literal>@Alternative</literal> stereotype, 
    the container automatically detects the problem and treats it as a deployment problem.</para>
    
    <!--
    <para><emphasis>Bean precedence</emphasis> defines a partial ordering of all enabled beans. 
    The precedence of a bean is used by the container to resolve ambiguous dependencies 
    and EL names, as specified in <xref linkend="ambigdependencies"/> and 
    <xref linkend="ambignames"/>.</para>
    
    <para>A bean X has a higher precedence than a second bean Y if either:</para>
    
    <itemizedlist>
      <listitem>
        <para>the first child element of <literal>&lt;alternatives&gt;</literal> that matches X 
        is earlier than the first child element of <literal>&lt;alternatives&gt;</literal> that 
        matches Y, or</para>
      </listitem>
      <listitem>
        <para>some child element of <literal>&lt;alternatives&gt;</literal> matches X, but no 
        child element of <literal>&lt;alternatives&gt;</literal> matches Y.</para>
      </listitem>
    </itemizedlist>
    -->
    
      <para>If the same type is listed twice under the <literal>&lt;alternatives&gt;</literal>
      element, the container automatically detects the problem and treats it as a 
      deployment problem.</para>
            
      <para>For a custom implementation of the <literal>Bean</literal> interface defined 
      in <xref linkend="bean"/>, the container calls <literal>isAlternative()</literal> to 
      determine whether the bean is an alternative, and <literal>getBeanClass()</literal> and 
      <literal>getStereotypes()</literal> to determine whether an alternative is selected in 
      a certain bean archive.</para>
      
    </section>
    
    <section id="enablement">
      <title>Enabled and disabled beans</title>
      
      <para>A bean is said to be <emphasis>enabled</emphasis> if:</para>
      
      <itemizedlist>
        <listitem><para>it is deployed in a bean archive, and</para></listitem>
        <listitem><para>it is not a producer method or field of a disabled bean, and</para></listitem>
        <listitem><para>it is not specialized by any other enabled bean, as defined in 
        <xref linkend="specialization"/>, and either</para></listitem>
        <listitem><para>it is not an alternative, or it is a selected alternative of at least 
        one bean archive.</para></listitem>
      </itemizedlist> 
      
      <para>Otherwise, the bean is said to be disabled.</para>
      
      <para>Note that <xref linkend="new"/> defines a special rule that determines whether
      a <literal>@New</literal> qualified bean is enabled or disabled. This rule applies as
      only to <literal>@New</literal> qualified beans, as an exception to the normal rule
      defined here.</para>
      
    </section>
            
    <section>
      <title>Inconsistent specialization</title>
      
      <para>Suppose an enabled bean X specializes a second bean Y. If there is another enabled 
      bean that specializes Y we say that <emphasis>inconsistent specialization</emphasis> 
      exists. The container automatically detects inconsistent specialization and treats it as 
      a deployment problem.</para> 
               
    </section>
    
    <section>
      <title>Inter-module injection</title>
    
      <para>A bean is <emphasis>available for injection</emphasis> in a certain module if:</para>
    
      <itemizedlist>
        <listitem>
          <para>the bean is not an interceptor or decorator,</para>
        </listitem>
        <listitem>
          <para>the bean is enabled,</para>
        </listitem>
        <listitem>
          <para>the bean is either not an alternative, or the module is a bean archive and the 
          bean is a selected alternative of the bean archive, and</para> 
        </listitem>
        <listitem>
          <para>the bean class is required to be accessible to classes in the module, 
          according to the class accessibility requirements of the module architecture.</para>
        </listitem>
      </itemizedlist>
    
      <para>For a custom implementation of the <literal>Bean</literal> interface 
      defined in <xref linkend="bean"/>, the container calls <literal>getBeanClass()</literal> 
      to determine the bean class of the bean and <literal>InjectionPoint.getMember()</literal> 
      and then <literal>Member.getDeclaringClass()</literal> to determine the class that 
      declares an injection point.</para>
    
    </section>

  </section>

  
  <section id="typesaferesolution">
    <title>Typesafe resolution</title>

    <para>The process of matching a bean to an injection point is called 
    <emphasis>typesafe resolution</emphasis>. The container considers bean type and 
    qualifiers when resolving a bean to be injected to an injection point. The type and 
    qualifiers of the injection point are called the <emphasis>required type</emphasis> 
    and <emphasis>required qualifiers</emphasis>.
    Typesafe resolution usually occurs at application initialization time, 
    allowing the container to warn the user if any enabled beans have unsatisfied 
    or unresolvable ambiguous dependencies.</para>
    
    <para>A bean is <emphasis>assignable</emphasis> to a given injection point if:</para>
    
    <itemizedlist>
    
      <listitem>
        <para>The bean has a bean type that matches the required type. For this purpose, 
        primitive types are considered to match their corresponding wrapper types in 
        <literal>java.lang</literal> and array types are considered to match only if 
        their element types are identical. Parameterized and raw types are considered
        to match if they are identical or if the bean type is <emphasis>assignable</emphasis> 
        to the required type, as defined in <xref linkend="assignableparameters"/> or
        <xref linkend="assignableparametersdec"/>.</para>
      </listitem>
          
      <listitem>
        <para>The bean has all the required qualifiers. If no required qualifiers were 
        explicitly specified, the container assumes the required qualifier 
        <literal>@Default</literal>. A bean has a required qualifier if it has a qualifier 
        with (a) the same type and (b) the same annotation member value for each member 
        which is not annotated <literal>@javax.enterprise.util.Nonbinding</literal>.</para>
      </listitem>
    
    </itemizedlist>

    <para>A bean is eligible for injection to a certain injection point if:</para>

    <itemizedlist>
      <listitem>
        <para>it is available for injection in the module that contains the class that 
        declares the injection point, and</para>
      </listitem>
      <listitem>
        <para>it is assignable to the injection point (using
        <xref linkend="assignableparameters"/>).</para>
      </listitem>
    </itemizedlist>
    
    <para>For a custom implementation of the <literal>Bean</literal> interface defined in 
    <xref linkend="bean"/>, the container calls <literal>getTypes()</literal> and 
    <literal>getQualifiers()</literal> to determine the bean types and qualifiers.</para>
    
  <section id="ambigdependencies">
    <title>Unsatisfied and ambiguous dependencies</title>
  
    <para>An <emphasis>unsatisfied dependency</emphasis> exists at an injection
    point when no bean is eligible for injection to the injection point. An 
    <emphasis>ambiguous dependency</emphasis> exists at an injection point when 
    multiple beans are eligible for injection to the injection point.</para>
    
    <para>Note that an unsatisfied or ambiguous dependency cannot exist for a
    decorator delegate injection point, defined in 
    <xref linkend="delegateattribute"/>.</para>
    
    <!--
    <para>When an ambiguous dependency exists, the container attempts to resolve
    the ambiguity by examining the precedences of the matching beans, as 
    defined in <xref linkend="enablement"/>. If there is exactly one
    bean with a higher precedence than every other matching bean, the container 
    will select this bean, and the ambiguous dependency is called 
    <emphasis>resolvable</emphasis>.</para>
    -->
    
    <para>When an ambiguous dependency exists, the container attempts to resolve
    the ambiguity. The container eliminates all eligible beans that are not 
    alternatives, except for producer methods and fields of beans that are 
    alternatives. If there is exactly one bean remaining, the container will 
    select this bean, and the ambiguous dependency is called 
    <emphasis>resolvable</emphasis>.</para>

    <para>The container must validate all injection points of all enabled beans 
    and of all other Java EE component classes supporting injection when the 
    application is initialized to ensure that there are no unsatisfied or unresolvable 
    ambiguous dependencies. If an unsatisfied or unresolvable ambiguous dependency 
    exists, the container automatically detects the problem and treats it as a 
    deployment problem.</para>
    
    <para>For a custom implementation of the <literal>Bean</literal> interface
    defined in <xref linkend="bean"/>, the container calls 
    <literal>getInjectionPoints()</literal> to determine the set of injection 
    points.</para>
    
  </section>
  
  <section>
    <title>Legal injection point types</title>
    
    <para>Any legal bean type, as defined in <xref linkend="legalbeantypes"/>  may 
    be the required type of an injection point. Furthermore, the required type of
    an injection point may contain a wildcard type parameter. However, a type 
    variable is not a legal injection point type.</para>
      
    <para>If an injection point type is a type variable, the container 
    automatically detects the problem and treats it as a definition error.</para>
    
  </section>

    <section id="assignableparameters">
      <title>Assignability of raw and parameterized types</title>

      <para>A parameterized bean type is considered assignable to a raw required type if 
      the raw types are identical and all type parameters of the bean type are either
      unbounded type variables or <literal>java.lang.Object</literal>.</para>
      
      <para>A parameterized bean type is considered assignable to a parameterized required 
      type if they have identical raw type and for each parameter:</para>
      
      <itemizedlist>
        <listitem>
          <para>the required type parameter and the bean type parameter are actual 
          types with identical raw type, and, if the type is parameterized, the bean 
          type parameter is assignable to the required type parameter according to 
          these rules, or</para>
        </listitem>
        <listitem>
          <para>the required type parameter is a wildcard, the bean type parameter is 
          an actual type and the actual type is assignable to the upper bound, if any, 
          of the wildcard and assignable from the lower bound, if any, of the wildcard, 
          or</para>
        </listitem>
        <listitem>
          <para>the required type parameter is a wildcard, the bean type parameter is 
          a type variable and the upper bound of the type variable is assignable to or
          assignable from the upper bound, if any, of the wildcard and assignable from 
          the lower bound, if any, of the wildcard, or</para>
        </listitem>
        <listitem>
          <para>the required type parameter is an actual type, the bean type parameter 
          is a type variable and the actual type is assignable from the upper bound, if
          any, of the type variable, or</para>
        </listitem>
        <listitem>
          <para>the required type parameter and the bean type parameter are both type 
          variables and the upper bound of the required type parameter is assignable 
          to the upper bound, if any, of the bean type parameter.</para>
        </listitem>
      </itemizedlist>
      
      <para>For example, <literal>Dao</literal> is eligible for injection to any 
      injection point of type <literal>@Default Dao&lt;Order&gt;</literal>, 
      <literal>@Default Dao&lt;User&gt;</literal>, <literal>@Default Dao&lt;?&gt;</literal>,
      <literal>@Default Dao&lt;? extends Persistent&gt;</literal> or 
      <literal>@Default Dao&lt;X extends Persistent&gt;</literal> where 
      <literal>X</literal> is a type variable.</para>
      
      <programlisting><![CDATA[public class Dao<T extends Persistent> { ... }]]></programlisting>

      <para>Furthermore, <literal>UserDao</literal> is eligible for injection 
      to any injection point of type <literal>@Default Dao&lt;User&gt;</literal>, 
      <literal>@Default Dao&lt;?&gt;</literal>, 
      <literal>@Default Dao&lt;? extends Persistent&gt;</literal> or 
      <literal>@Default Dao&lt;? extends User&gt;</literal>.</para>
      
      <programlisting><![CDATA[public class UserDao extends Dao<User> { ... }]]></programlisting>
      
      <para>Note that a special set of rules, defined in <xref linkend="assignableparametersdec"/>,
      apply if and only if the injection point is a decorator delegate injection point.</para>
      
    </section>

  <section id="null">
    <title>Primitive types and null values</title>
    
    <para>For the purposes of typesafe resolution and dependency injection,
    primitive types and their corresponding wrapper types in the package
    <literal>java.lang</literal> are considered identical and assignable.
    If necessary, the container performs boxing or unboxing when it injects 
    a value to a field or parameter of primitive or wrapper type.</para>
    
    <para>However, if an injection point of primitive type resolves to a bean 
    that may have null values, such as a producer method with a non-primitive 
    return type or a producer field with a non-primitive type, the container 
    automatically detects the problem and treats it as a deployment problem.</para>
    
    <para>For a custom implementation of the <literal>Bean</literal> interface
    defined in <xref linkend="bean"/>, the container calls 
    <literal>isNullable()</literal> to determine whether the bean may have null 
    values.</para>
    
  </section>
  
    <section id="qualifierannotationmembers">
      <title>Qualifier annotations with members</title>

      <para>Qualifier types may have annotation members.</para>

      <programlisting>@PayBy(CHEQUE) class ChequePaymentProcessor implements PaymentProcessor { ... }</programlisting>

      <programlisting>@PayBy(CREDIT_CARD) class CreditCardPaymentProcessor implements PaymentProcessor { ... }</programlisting>

      <para>Then only <literal>ChequePaymentProcessor</literal> is a candidate for
      injection to the following attribute:</para>

      <programlisting>@Inject @PayBy(CHEQUE) PaymentProcessor paymentProcessor;</programlisting>

      <para>On the other hand, only <literal>CreditCardPaymentProcessor</literal> is a 
      candidate for injection to this attribute:</para>

      <programlisting>@Inject @PayBy(CREDIT_CARD) PaymentProcessor paymentProcessor;</programlisting>

      <para>The container calls the <literal>equals()</literal> method of the
      annotation member value to compare values.</para>

      <para>An annotation member may be excluded from consideration using the
      <literal>@Nonbinding</literal> annotation.</para>
      
      <programlisting>@Qualifier
@Retention(RUNTIME)
@Target({METHOD, FIELD, PARAMETER, TYPE})
public @interface PayBy {
    PaymentMethod value();
    @Nonbinding String comment() default "";
}</programlisting>

      <para>Array-valued or annotation-valued members of a qualifier type should be 
      annotated <literal>@Nonbinding</literal> in a portable application. If an
      array-valued or annotation-valued member of a qualifier type is not annotated 
      <literal>@Nonbinding</literal>, non-portable behavior results.</para>
      
    </section>

    <section>
      <title>Multiple qualifiers</title>

      <para>A bean class or producer method or field may declare multiple qualifiers.</para>

      <programlisting>@Synchronous @PayBy(CHEQUE) class ChequePaymentProcessor implements PaymentProcessor { ... }</programlisting>

      <para>Then <literal>ChequePaymentProcessor</literal> would be considered a candidate 
      for injection into any of the following attributes:</para>

      <programlisting>@Inject @PayBy(CHEQUE) PaymentProcessor paymentProcessor;</programlisting>

      <programlisting>@Inject @Synchronous PaymentProcessor paymentProcessor;</programlisting>

      <programlisting>@Inject @Synchronous @PayBy(CHEQUE) PaymentProcessor paymentProcessor;</programlisting>

      <para>A bean must declare <emphasis>all</emphasis> of the qualifiers that are 
      specified at the injection point to be considered a candidate for injection.</para>
      
    </section>
    
  </section>

  <section id="nameresolution">
    <title>EL name resolution</title>

    <para>The process of matching a bean to a name used in EL is called 
    <emphasis>name resolution</emphasis>. Since there is no typing information 
    available in EL, the container may consider only the EL name. Name resolution 
    usually occurs at runtime, during EL expression evaluation.</para>

    <para>An EL name resolves to a bean if:</para>
    
    <itemizedlist>
      <listitem>the bean has the given EL name, and</listitem>
      <listitem>the bean is available for injection in the war containing
      the JSP or JSF page with the EL expression.</listitem>
    </itemizedlist>
    
    <para>For a custom implementation of the <literal>Bean</literal> interface
    defined in <xref linkend="bean"/>, the container calls <literal>getName()</literal> 
    to determine the bean EL name.</para>
    
    <section id="ambignames">
      <title>Ambiguous EL names</title>
      
      <para>An <emphasis>ambiguous EL name</emphasis> exists in an EL expression
      when an EL name resolves to multiple beans. When an ambiguous EL name exists, 
      the container attempts to resolve the ambiguity. The container eliminates all 
      beans that are not alternatives, except for producer methods and fields of 
      beans that are alternatives. If there is exactly one bean remaining, the 
      container will select this bean, and the ambiguous EL name is called 
      <emphasis>resolvable</emphasis>.</para>
      
      <para>All unresolvable ambiguous EL names are detected by the container when
      the application is initialized. Suppose two beans are both available for 
      injection in a certain war, and either:</para>
      
      <itemizedlist>
        <listitem>
          <para>the two beans have the same EL name and the name is not resolvable,
          or</para>
        </listitem>
        <listitem>
          <para>the EL name of one bean is of the form <literal>x.y</literal>, 
          where <literal>y</literal> is a valid bean EL name, and <literal>x</literal> 
          is the EL name of the other bean,</para>
        </listitem>
      </itemizedlist>
      
      <para>the container automatically detects the problem and treats it as a 
      deployment problem.</para>
        
    </section>
    
  </section>
  
  <section id="clientproxies">
    <title>Client proxies</title>
    
    <para>An injected reference, or reference obtained by programmatic
    lookup, is usually a <emphasis>contextual reference</emphasis> as 
    defined by <xref linkend="contextualreference"/>.</para>
    
    <para>A contextual reference to a bean with a normal scope, as defined in
    <xref linkend="normalscope"/>, is not a direct reference to a contextual 
    instance of the bean (the object returned by <literal>Contextual.create()</literal>). 
    Instead, the contextual reference is a <emphasis>client proxy</emphasis> object. 
    A client proxy implements/extends some or all of the bean types of the bean and 
    delegates all method calls to the current instance (as defined in 
    <xref linkend="normalscope"/>) of the bean.</para>
    
    <para>There are a number of reasons for this indirection:</para>
    
    <itemizedlist>
    
      <listitem>
        <para>The container must guarantee that when any valid injected 
        reference to a bean of normal scope is invoked, the invocation is 
        always processed by the current instance of the injected bean. In 
        certain scenarios, for example if a request scoped bean is injected 
        into a session scoped bean, or into a servlet, this rule requires 
        an indirect reference. (Note that the <literal>@Dependent</literal> 
        pseudo-scope is not a normal scope.)</para>
      </listitem>
    
      <listitem>
        <para>The container may use a client proxy when creating beans 
        with circular dependencies. This is only necessary when the circular 
        dependencies are initialized via a managed bean constructor or producer 
        method parameter. (Beans with scope <literal>@Dependent</literal> never 
        have circular dependencies.)</para>
      </listitem>
      
      <listitem>
        <para>Finally, client proxies may be passivated, even when the 
        bean itself may not be. Therefore the container must use a client 
        proxy whenever a bean with normal scope is injected into a bean with
        a passivating scope, as defined in <xref linkend="passivatingscope"/>.
        (On the other hand, beans with scope <literal>@Dependent</literal> 
        must be serialized along with their client.)</para>
      </listitem>
    
    </itemizedlist>
    
    <para>Client proxies are never required for a bean whose scope is a
    pseudo-scope such as <literal>@Dependent</literal>.</para>
    
    <para>Client proxies may be shared between multiple injection points. For 
    example, a particular container might instantiate exactly one client
    proxy object per bean. (However, this strategy is not required by this
    specification.)</para>
    
    <section id="unproxyable">
      <title>Unproxyable bean types</title>
    
      <para>Certain legal bean types cannot be proxied by the container:</para>
    
      <itemizedlist>
        <listitem>
          <para>classes which don't have a non-private constructor with no 
          parameters,</para>
        </listitem>
        <listitem>
          <para>classes which are declared final or have non-private final 
          methods,</para>
        </listitem>
        <listitem>
          <para>primitive types,</para>
        </listitem>
        <listitem>
          <para>and array types.</para>
        </listitem>
      </itemizedlist>
    
      <para>If an injection point whose declared type cannot be proxied by the 
      container resolves to a bean with a normal scope, the container automatically 
      detects the problem and treats it as a deployment problem.</para>
    
    </section>
    
    <section>
      <title>Client proxy invocation</title>
      
      <para>Every time a method of the bean is invoked upon a client proxy,
      the client proxy must:</para>
    
      <itemizedlist>
        <listitem>
          <para>obtain a contextual instance of the bean, as defined in
          <xref linkend="contextualinstance"/>, and</para>
        </listitem>
        <listitem>
          <para>invoke the method upon this instance.</para>
        </listitem>
      </itemizedlist>
      
      <para>If the scope is not active, as specified in <xref linkend="activecontext"/>,
      the client proxy rethrows the <literal>ContextNotActiveException</literal> or
      <literal>IllegalStateException</literal>.</para>
    
      <para>The behavior of all methods declared by <literal>java.lang.Object</literal>, 
      except for <literal>toString()</literal>, is undefined for a client proxy. Portable 
      applications should not invoke any method declared by <literal>java.lang.Object</literal>, 
      except for <literal>toString()</literal>, on a client proxy.</para>
      
    </section>
    
  </section>
  
  <section id="injection">
    <title>Dependency injection</title>
    
    <para>From time to time the container instantiates beans and other
    Java EE component classes supporting injection. The resulting instance 
    may or may not be a <emphasis>contextual instance</emphasis> as defined 
    by <xref linkend="contextualinstance"/>.</para>
        
    <para>The container is required to perform dependency injection whenever
    it creates one of the following contextual objects:</para>
    
    <itemizedlist>
      <listitem>
        <para>contextual instances of session beans, and</para>
      </listitem>
      <listitem>
        <para>contextual instances of managed beans.</para>
      </listitem>
    </itemizedlist>
    
    <para>The container is also required to perform dependency injection 
    whenever it instantiates any of the following non-contextual objects:</para>
    
    <itemizedlist>
      <listitem>
        <para>non-contextual instances of session beans (for example, 
        session beans obtained by the application from JNDI or injected
        using <literal>@EJB</literal>),</para>
      </listitem>
      <listitem>
        <para>non-contextual instances of managed beans, and</para>
      </listitem>
      <listitem>
        <para>instances of any other Java EE component class supporting 
        injection.</para>
      </listitem>
    </itemizedlist>
    
    <para>A Java EE 5 container is not required to support injection for 
    non-contextual objects.</para>
    
    <para>The container interacts with instances of beans and other Java EE
    component classes supporting injection by calling methods and getting
    and setting field values.</para>
    
    <para>The object injected by the container may not be a direct reference
    to a contextual instance of the bean. Instead, it is an injectable 
    reference, as defined by <xref linkend="injectableinstance"/>.</para>
    
    <section id="instantiation">
      <title>Injection using the bean constructor</title>
    
      <para>When the container instantiates a managed bean or session bean with 
      a constructor annotated <literal>@Inject</literal>, the container calls 
      this constructor, passing an injectable reference to each parameter. If 
      there is no constructor annotated <literal>@Inject</literal>, the container 
      calls the constructor with no parameters.</para>
    
    </section>
    
    <section id="fieldsinitializermethods">
      <title>Injection of fields and initializer methods</title>

      <para>When the container creates a new instance of a managed bean, session
      bean, or of any other Java EE component class supporting injection, the 
      container must:</para>
      
      <itemizedlist>
        <listitem>
          <para>Initialize the values of all injected fields. The container sets 
          the value of each injected field to an injectable reference.</para>
        </listitem>
        <listitem>
          <para>Call all initializer methods, passing an injectable reference to 
          each parameter.</para>
        </listitem>
      </itemizedlist>
      
      <para>The container must ensure that:</para>
      
      <itemizedlist>
        <listitem>
          <para>Initializer methods declared by a class X in the type hierarchy 
          of the bean are called after all injected fields declared by X or by 
          superclasses of X have been initialized, and after all Java EE 
          component environment resource dependencies declared by X or by
          superclasses of X have been injected.</para>
        </listitem>
        <listitem>
          <para>Any <literal>@PostConstruct</literal> callback declared by a class 
          X in the type hierarchy of the bean is called after all initializer
          methods declared by X or by superclasses of X have been called, 
          after all injected fields declared by X or by superclasses of X have 
          been initialized, and after all Java EE component environment resource 
          dependencies declared by X or by superclasses of X have been injected.</para>
        </listitem>
        <listitem>
          <para>Any servlet <literal>init()</literal> method is called after all
          initializer methods have been called, all injected fields have been 
          initialized and all Java EE component environment resource dependencies 
          have been injected.</para>
        </listitem>
      </itemizedlist>
    
    </section>
    
    <section id="destruction">
      <title>Destruction of dependent objects</title>
      
      <para>When the container destroys an instance of a bean or of any Java EE 
      component class supporting injection, the container destroys all dependent 
      objects, as defined in <xref linkend="dependentdestruction"/>, 
      after the <literal>@PreDestroy</literal> callback completes and after the 
      servlet <literal>destroy()</literal> method is called.</para>
    
    </section>
    
    <section id="methods">
      <title>Invocation of producer or disposer methods</title>
      
      <para>When the container calls a producer or disposer method, the
      behavior depends upon whether the method is static or non-static:</para>
      
      <itemizedlist>
        
        <listitem>
          <para>If the method is static, the container must invoke the method.</para>
        </listitem>
        
        <listitem>
          <para>Otherwise, if the method is non-static, the container must:</para>
          <itemizedlist>
            <!--listitem>
              <para>Determine the most specialized enabled bean that specializes 
              the bean which declares the method, as defined in 
              <xref linkend="mostspecialized"/>.</para>
            </listitem-->
            <listitem>
              <para>Obtain a contextual instance of the bean which declares the
              method, as defined by <xref linkend="contextualinstance"/>.</para>
            </listitem>
            <listitem>
              <para>Invoke the method upon this instance, as a business method 
              invocation, as defined in <xref linkend="bizmethod"/>.</para>
            </listitem>
          </itemizedlist>
        </listitem>
        
      </itemizedlist>

      <para>The container passes an injectable reference to each injected method 
      parameter. The container is also responsible for destroying dependent objects 
      created during this invocation, as defined in 
      <xref linkend="dependentdestruction"/>.</para>
    
    </section>
      
  <section id="fields">
    <title>Access to producer field values</title>
    
    <para>When the container accesses the value of a producer field, the value
    depends upon whether the field is static or non-static:</para>
    
    <itemizedlist>
    
      <listitem>
        <para>If the producer field is static, the container must access the field 
        value.</para>
      </listitem>
    
      <listitem>
        <para>Otherwise, if the producer field is non-static, the container
        must:</para>
        <itemizedlist>
          <!--listitem>
            <para>Determine the most specialized enabled bean that specializes the 
            bean which declares the producer field, as defined in 
            <xref linkend="mostspecialized"/>.</para>
          </listitem-->
          <listitem>
            <para>Obtain an contextual instance of the bean which declares the 
            producer field, as defined by <xref linkend="contextualinstance"/>.</para>
          </listitem>
          <listitem>
            <para>Access the field value of this instance.</para>
          </listitem>
        </itemizedlist>
      </listitem>
    
    </itemizedlist>
    
  </section>
  
  <section id="observers">
    <title>Invocation of observer methods</title>
  
    <para>When the container calls an observer method (defined in <xref linkend="observermethods"/>), 
    the behavior depends upon whether the method is static or non-static:</para>
      
    <itemizedlist>
      
      <listitem>
        <para>If the observer method is static, the container must invoke the method.</para>
      </listitem>

      <listitem>
        <para>Otherwise, if the observer method is non-static, the container must:</para>
        <itemizedlist>
          <!--listitem>
            <para>Determine the most specialized enabled bean that specializes the bean 
            which declares the observer method, as defined in 
            <xref linkend="mostspecialized"/>.</para>
          </listitem-->
          <listitem>
            <para>Obtain a contextual instance of the bean which declares the observer method
            according to <xref linkend="contextualinstance"/>. If this observer method is a 
            conditional observer method, obtain the contextual instance that already exists, 
            only if the scope of the bean that declares the observer method is currently active, 
            without creating a new contextual instance.</para>
          </listitem>
          <listitem>
            <para>Invoke the observer method on the resulting instance, if any, as a 
            business method invocation, as defined in <xref linkend="bizmethod"/>.</para>
          </listitem>
        </itemizedlist>
      </listitem>
      
    </itemizedlist>
      
    <para>The container must pass the event object to the event parameter and an injectable 
    instance to each injected method parameter. The container is also responsible for 
    destroying dependent objects created during this invocation, as defined in 
    <xref linkend="dependentdestruction"/>.</para>
  
  </section>

  <section id="injectionpoint">
    <title>Injection point metadata</title>
    
    <para>The interface <literal>javax.enterprise.inject.spi.InjectionPoint</literal> provides access 
    to metadata about an injection point. An instance of <literal>InjectionPoint</literal> may
    represent:</para>
    
    <itemizedlist>
      <listitem>
        <para>an injected field or a parameter of a bean constructor, initializer method,
    	producer method, disposer method or observer method, or</para>
   	  </listitem>
   	  <listitem>
   	    <para>an instance obtained dynamically using <literal>Instance.get()</literal>.</para>
   	  </listitem>
    </itemizedlist>
    
    <programlisting><![CDATA[public interface InjectionPoint {
    public Type getType();
    public Set<Annotation> getQualifiers();
    public Bean<?> getBean();
    public Member getMember();
    public Annotated getAnnotated();
    public boolean isDelegate();
    public boolean isTransient();
}]]></programlisting>

    <itemizedlist>
      <listitem>
        <para>The <literal>getBean()</literal> method returns the <literal>Bean</literal> object 
        representing the bean that defines the injection point. If the injection point does not
        belong to a bean, <literal>getBean()</literal> returns a null value. If the injection 
        point represents a dynamically obtained instance, the <literal>getBean()</literal> method
        should return the <literal>Bean</literal> object representing the bean that defines the 
        <literal>Instance</literal> injection point.</para>
      </listitem>
      <listitem>
        <para>The <literal>getType()</literal> and <literal>getQualifiers()</literal> methods 
        return the required type and required qualifiers of the injection point. If the injection 
        point represents a dynamically obtained instance, the <literal>getType()</literal> and 
        <literal>getQualifiers()</literal> methods should return the required type (as defined
        by <literal>Instance.select()</literal>), and required qualifiers of the injection point
        including any additional required qualifers (as defined by 
        <literal>Instance.select()</literal>).</para>
      </listitem>
      <listitem>
        <para>The <literal>getMember()</literal> method returns the <literal>Field</literal> object 
        in the case of field injection, the <literal>Method</literal> object in the case of method 
        parameter injection, or the <literal>Constructor</literal> object in the case of constructor 
        parameter injection. If the injection point represents a dynamically obtained instance, 
        the <literal>getMember()</literal> method returns the <literal>Field</literal> object 
        representing the field that defines the <literal>Instance</literal> injection point
        in the case of field injection, the <literal>Method</literal> object representing the method
        that defines the <literal>Instance</literal> injection point in the case of method 
        parameter injection, or the <literal>Constructor</literal> object representing the 
        constructor that defines the <literal>Instance</literal> injection point in the case of
        constructor parameter injection.</para>
      </listitem>
      <listitem>
        <para>The <literal>getAnnotated()</literal> method returns an instance of
        <literal>javax.enterprise.inject.spi.AnnotatedField</literal> or 
        <literal>javax.enterprise.inject.spi.AnnotatedParameter</literal>, depending upon whether 
        the injection point is an injected field or a constructor/method parameter. If the 
        injection point represents a dynamically obtained instance, then the 
        <literal>getAnnotated()</literal>method returns an instance of
        <literal>javax.enterprise.inject.spi.AnnotatedField</literal> or 
        <literal>javax.enterprise.inject.spi.AnnotatedParameter</literal> representing the 
        <literal>Instance</literal> injection point, depending upon whether the injection point is an injected
        field or a constructor/method parameter.</para> 
      </listitem>
      <listitem>
        <para>The <literal>isDelegate()</literal> method returns <literal>true</literal>
        if the injection point is a decorator delegate injection point, and 
        <literal>false</literal> otherwise. If the injection point represents a dynamically 
        obtained instance then <literal>isDelegate()</literal> return false.</para>
      </listitem>
      <listitem>
        <para>The <literal>isTransient()</literal> method returns <literal>true</literal> 
        if the injection point is a transient field, and <literal>false</literal> otherwise. If the
        injection point represents a dynamically obtained instance then the 
        <literal>isTransient()</literal> method returns <literal>true</literal> if the 
        <literal>Instance</literal> injection point is a transient field, and <literal>false</literal> 
        otherwise.</para>
      </listitem>
    </itemizedlist>
    
    <para>Occasionally, a component with scope <literal>@Dependent</literal> needs to access
    metadata relating to the object into which it is injected. For example, the following 
    producer method creates injectable <literal>Logger</literal>s. The log category of a
    <literal>Logger</literal> depends upon the class of the object into which it is injected:</para>
    
    <programlisting><![CDATA[@Produces Logger createLogger(InjectionPoint injectionPoint) {
    return Logger.getLogger( injectionPoint.getMember().getDeclaringClass().getName() );    
}]]></programlisting>

    <para>The container must provide a bean with scope <literal>@Dependent</literal>, bean 
    type <literal>InjectionPoint</literal> and qualifier <literal>@Default</literal>, allowing 
    dependent objects, as defined in <xref linkend="dependentobjects"/>, to obtain information 
    about the injection point to which they belong. The built-in implementation must be a 
    passivation capable dependency, as defined in <xref linkend="passivationcapabledependency"/>.</para>
    
    <para>If a bean that declares any scope other than <literal>@Dependent</literal> has an
    injection point of type <literal>InjectionPoint</literal> and qualifier <literal>@Default</literal>,
    the container automatically detects the problem and treats it as a definition error.</para>
    
    <para>If a Java EE component class supporting injection that is not a bean has an 
    injection point of type <literal>InjectionPoint</literal> and qualifier <literal>@Default</literal>, 
    the container automatically detects the problem  and treats it as a definition error.</para>
    
    <para>The <literal>InjectionPoint</literal> injected into a disposer method represents the producer
    method for which the disposer method is being invoked.</para>
    
    <para>The <literal>InjectionPoint</literal> injected into a decorator represents the injection point
    on the bean the decorated type is injected into.</para>
    
  </section>

  </section>
  
  <section>
    <title>Programmatic lookup</title>
      
      <para>In certain situations, injection is not the most convenient way to obtain a 
      contextual reference. For example, it may not be used when:</para>
      
      <itemizedlist>
        <listitem>
          <para>the bean type or qualifiers vary dynamically at runtime, or</para>
        </listitem>
        <listitem>
          <para>depending upon the deployment, there may be no bean which satisfies 
          the type and qualifiers, or</para>
        </listitem>
        <listitem>
          <para>we would like to iterate over all beans of a certain type.</para>
        </listitem>
      </itemizedlist>
      
      <para>In these situations, an instance of the <literal>javax.enterprise.inject.Instance</literal> 
      interface may be injected:</para>
      
      <programlisting>@Inject Instance&lt;PaymentProcessor&gt; paymentProcessor;</programlisting>
      
      <para>The method <literal>get()</literal> returns a contextual reference:</para>
      
      <programlisting>PaymentProcessor pp = paymentProcessor.get();</programlisting>
      
      <para>Any combination of qualifiers may be specified at the injection point:</para>
      
      <programlisting>@Inject @PayBy(CHEQUE) Instance&lt;PaymentProcessor&gt; chequePaymentProcessor;</programlisting>
      
      <para>Or, the <literal>@Any</literal> qualifier may be used, allowing the application 
      to specify qualifiers dynamically:</para>
      
      <programlisting>@Inject @Any Instance&lt;PaymentProcessor&gt; anyPaymentProcessor;
...
Annotation qualifier = synchronously ? new SynchronousQualifier() : new AsynchronousQualifier();
PaymentProcessor pp = anyPaymentProcessor.select(qualifier).get().process(payment);
</programlisting>
      
      <para>In this example, the returned bean has qualifier <literal>@Synchronous</literal> 
      or <literal>@Asynchronous</literal> depending upon the value of 
      <literal>synchronously</literal>.</para>
      
      <para>Finally, the <literal>@New</literal> qualifier may be used, allowing the 
      application to obtain a <literal>@New</literal> qualified bean, as defined in
      <xref linkend="new"/>:</para>
      
      <programlisting>@Inject @New(ChequePaymentProcessor.class) Instance&lt;PaymentProcessor&gt; chequePaymentProcessor;</programlisting>

      <para>It's even possible to iterate over a set of beans:</para>
      
      <programlisting>@Inject @Any Instance&lt;PaymentProcessor&gt; anyPaymentProcessor;
...
for (PaymentProcessor pp: anyPaymentProcessor) pp.test();
</programlisting>
      
      <section id="dynamiclookup">   
        <title>The <literal>Instance</literal> interface</title>

      <para>The <literal>Instance</literal> interface provides a method for obtaining
      instances of beans with a specified combination of required type and qualifiers, and 
      inherits the ability to iterate beans with that combination of required type and 
      qualifiers from <literal>java.lang.Iterable</literal>:</para>
      
      <programlisting><![CDATA[public interface Instance<T> extends Iterable<T>, Provider<T> {
      
    public Instance<T> select(Annotation... qualifiers);
    public <U extends T> Instance<U> select(Class<U> subtype, Annotation... qualifiers);
    public <U extends T> Instance<U> select(TypeLiteral<U> subtype, Annotation... qualifiers);
    
    public boolean isUnsatisfied();
    public boolean isAmbiguous();
      
}]]></programlisting>

      <para>For an injected <literal>Instance</literal>:</para>
      
      <itemizedlist>
        <listitem>
          <para>the <emphasis>required type</emphasis> is the type parameter specified 
          at the injection point, and</para>
        </listitem>
        <listitem>
          <para>the <emphasis>required qualifiers</emphasis> are the qualifiers specified 
          at the injection point.</para>
        </listitem>
      </itemizedlist>

      <para>For example, this injected <literal>Instance</literal> has required type 
      <literal>PaymentProcessor</literal> and required qualifier <literal>@Any</literal>:</para>
      
      <programlisting>@Inject @Any Instance&lt;PaymentProcessor&gt; anyPaymentProcessor;</programlisting>
      
      <para>The <literal>select()</literal> method returns a child <literal>Instance</literal> 
      for a given required type and additional required qualifiers. If no required type 
      is given, the required type is the same as the parent.</para>
      
      <para>For example, this child <literal>Instance</literal> has required type 
      <literal>AsynchronousPaymentProcessor</literal> and additional required qualifier 
      <literal>@Asynchronous</literal>:</para>
      
      <programlisting>Instance&lt;AsynchronousPaymentProcessor&gt; async = anyPaymentProcessor.select( 
            AsynchronousPaymentProcessor.class, new AsynchronousQualifier() );</programlisting>

      <para>If two instances of the same qualifier type are passed to 
      <literal>select()</literal>, an <literal>IllegalArgumentException</literal> 
      is thrown.</para>
      
      <para>If an instance of an annotation that is not a qualifier type is passed 
      to <literal>select()</literal>, an <literal>IllegalArgumentException</literal> 
      is thrown.</para>
      
      <!--
      <para>If an instance of <literal>javax.enterprise.inject.New</literal> is 
      passed to <literal>select()</literal>, non-portable behavior results. Portable
      applications should not pass qualifiers of type <literal>@New</literal> to
      <literal>select()</literal>.</para>
      -->

      <para>The <literal>get()</literal> method must:</para>

      <itemizedlist>
    
      <listitem>
        <para>Identify a bean that has the required type and required qualifiers
        and is eligible for injection into the class into which the parent 
        <literal>Instance</literal> was injected, according to the rules of typesafe 
        resolution, as defined in <xref linkend="typesaferesolution"/>, resolving 
        ambiguities according to <xref linkend="ambigdependencies"/>.</para>
      </listitem>
      
      <listitem>
        <para>If typesafe resolution results in an unsatisfied dependency, throw an 
        <literal>UnsatisfiedResolutionException</literal>. If typesafe resolution 
        results in an unresolvable ambiguous dependency, throw an 
        <literal>AmbiguousResolutionException</literal>.</para>
      </listitem>
      
      <listitem>
        <para>Otherwise, obtain a contextual reference for the bean and the required
        type, as defined in <xref linkend="contextualreference"/>.</para>
      </listitem>

      </itemizedlist>

      <para>The <literal>iterator()</literal> method must:</para>

      <itemizedlist>
    
      <listitem>
        <para>Identify the set of beans that have the required type and required 
        qualifiers and are eligible for injection into the class into which the parent 
        <literal>Instance</literal> was injected, according to the rules of typesafe 
        resolution, as defined in <xref linkend="typesaferesolution"/>.</para>
      </listitem>
      
      <listitem>
        <para>Return an <literal>Iterator</literal>, that iterates over the set 
        of contextual references for the resulting beans and required type, as
        defined in <xref linkend="contextualreference"/>.</para>
      </listitem>

      </itemizedlist>
      
      <para>The method <literal>isUnsatisfied()</literal> returns <literal>true</literal>
      if there is no bean that has the required type and qualifiers and is eligible 
      for injection into the class into which the parent <literal>Instance</literal> was 
      injected, or <literal>false</literal> otherwise.</para>
      
      <para>The method <literal>isAmbiguous()</literal> returns <literal>true</literal>
      if there is more than one bean that has the required type and qualifiers and is 
      eligible for injection into the class into which the parent <literal>Instance</literal> 
      was injected, or <literal>false</literal> otherwise.</para>
      
      </section>
      
      <section>
        <title>The built-in <literal>Instance</literal></title>
      
      <para>The container must provide a built-in bean with:</para>
      
      <itemizedlist>
        <listitem>
          <para><literal>Instance&lt;X&gt;</literal> and <literal>Provider&lt;X&gt;</literal> 
          for every legal bean type <literal>X</literal> in its set of bean types,</para>
        </listitem>
        <listitem>
          <para>every qualifier type in its set of qualifier types,</para>
        </listitem>
        <listitem>
          <para>scope <literal>@Dependent</literal>,</para>
        </listitem>
        <listitem>
          <para>no bean EL name, and</para>
        </listitem>
        <listitem>
          <para>an implementation provided automatically by the container.</para>
        </listitem>
      </itemizedlist>

      <para>The built-in implementation must be a passivation capable dependency,
      as defined in <xref linkend="passivationcapabledependency"/>.</para>
      
      </section>
      
      <section>
        <title>Using <literal>AnnotationLiteral</literal> and <literal>TypeLiteral</literal></title>

        <para><literal>javax.enterprise.util.AnnotationLiteral</literal><!--, defined in
        <xref linkend="annotationliteral"/>--> makes it easier to specify qualifiers when 
        calling <literal>select()</literal>:</para>
        
        <programlisting><![CDATA[public PaymentProcessor getSynchronousPaymentProcessor(PaymentMethod paymentMethod) {
    
    class SynchronousQualifier extends AnnotationLiteral<Synchronous>
            implements Synchronous {}
    
    class PayByQualifier extends AnnotationLiteral<PayBy>
            implements PayBy {
        public PaymentMethod value() { return paymentMethod; }
    }
    
    return anyPaymentProcessor.select(new SynchronousQualifier(), new PayByQualifier()).get();
}]]></programlisting>
        
        <para><literal>javax.enterprise.util.TypeLiteral</literal><!--, defined in 
        <xref linkend="typeliteral"/>--> makes it easier to specify a parameterized type 
        with actual type parameters when calling <literal>select()</literal>:</para>
        
       <programlisting><![CDATA[public PaymentProcessor<Cheque> getChequePaymentProcessor() {
    PaymentProcessor<Cheque> pp = anyPaymentProcessor
        .select( new TypeLiteral<PaymentProcessor<Cheque>>() {} ).get();
}]]></programlisting>
        
      
      </section>
    
  </section>
  
</chapter>